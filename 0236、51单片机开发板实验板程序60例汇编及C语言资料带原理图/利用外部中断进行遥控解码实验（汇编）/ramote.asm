;**********************************************************************
;****************************红外解码实验******************************
;**********************************************************************




;----------------------------对TC9012 (长虹 K8B )遥控器的解码----------------------
;----------------------------------------------------------------------
; 2005.5.03  design by benladn911   调试成功!!!!!!
; 参考网站：www.xie-gang.com
;----------------------------------------------------------------------
;系统采用 AT89C51 进行解码实验, fosc = 12 MHz




;这种遥控码具有以下特征,采用脉宽调制的串行码




;以脉宽为0.565ms低电平、0.56ms高电平、周期为1.125ms的组合表示二进制的“0”；




;以脉宽为0.565ms低电平、1.685ms高电平、周期为2.25ms的组合表示二进制的“1”





;解码的关键是如何识别“0”和“1”，从位的定义我们可以发现“0”、“1”均以0.56ms的低电平开始，
;不同的是高电平的宽度不同，“0”为0.56ms,“1”为1.68ms, 所以必须根据高电平的宽度区别“0”和“1”。
;如果从0.56ms低电平过后，开始延时，0.56ms以后，若读到的电平为低，说明该位为“0”，反之则为“1”，




;为了可*起见，延时必须比0.56ms长些，但又不能超过1.12ms,否则如果该位为“0”，读到的已是下一位的高电平，
;因此取（1.12ms+0.56ms）/2=0.84ms最为可*，一般取0.84ms左右即可。




;根据 TC9012 红外编码的格式，程序应该等待 4.5ms 的起始码和 4.5ms 的结果码完成后才能读码。






ORG 0000H
AJMP MAIN




ORG 0003H   ;外部中断P3.2脚INT0入口地址
AJMP INTT0  ;转入外部中断服务子程序（解码程序）




ORG 0100H
MAIN: SETB EA
      SETB IT0
      SETB EX0




      AJMP $





;******************以下为进入P3.2脚外部中断子程序，也就是解码程序*******************




INTT0: CLR EA ;暂时关闭CPU的所有中断请求




MOV R6,#5
SB: ACALL YS1      ;调用882微秒延时子程序
    JB P3.2,EXIT   ;延时882微秒后判断P3.2脚是否出现高电平如果有就退出解码程序
    DJNZ R6, SB    ;重复 5 次，目的是检测在 4410 微秒内如果出现高电平就退出解码程序




;---------------以上完成对遥控信号引导码的 4500 微秒的初始低电平信号的识别!!!!!




JNB P3.2, $    ;等待高电平避开 4.5 毫秒低电平引导脉冲
ACALL YS2      ;延时4.74毫秒避开 4.5 毫秒的结果码
;---------------以上是对引导码的 4500 微秒高电平的初始识别!!!!!




;-------------------------------------------------------------------------




MOV R7,#16    ;忽略前16位系统识别码 (即地址码)




JJJJA:JNB P3.2,$   ;等待地址码第一位的高电平信号
      LCALL YS1    ;高电平开始后用882微秒的时间延时去判断信号此时的高低电平状态
      MOV C,P3.2   ;将P3.2引脚此时的电平状态 0或1 存入C中
      JNC UUUA     ;如果为0就跳转到UUUA
      LCALL YS3    ;检测到高电平1的话延时1毫秒等待脉冲高电平结束
UUUA: DJNZ R7,JJJJA




;--------------------------------------------------------------------------




MOV R1,#1AH   ;设定1AH为起始RAM区
MOV R2,#2     ;接收从1AH到1BH的2个内存,用于存放操作码 (即数据码) 和操作反码
PP: MOV R3,#8 ;每组数据为8位




JJJJ: JNB P3.2,$   ;等待 数据码 第一位的高电平信号
      LCALL YS1    ;高电平开始后用882微秒的时间尺去判断信号此时的高低电平状态
      MOV C,P3.2   ;将P3.2引脚此时的电平状态0或1存入C中
      JNC UUU      ;如果为0就跳转到UUU
      LCALL YS3    ;检测到高电平1的话延时1毫秒等待脉冲高电平结束




UUU: MOV A,@R1   ;将R1中地址的给A
     RRC A       ;将C中的值0或1移入A中的最低位
     MOV @R1,A   ;将A中的数暂时存放在R1数值的内存中
     DJNZ R3,JJJJ   ;接收满8位换一个内存
     INC R1    ;对R1中的值加1，换下一个RAM
     DJNZ R2,PP   ;接收完8位数据码和8位数据反码，存放在1AH/1BH中




MOV A,1AH
CPL A   ;对1AH取反后和1BH比较
CJNE A,1BH,EXIT   ;如果不等表示接收数据发生错误,放弃




;---------------------------------------------------------------------




MOV P0,1AH  ;将按键的键值通过P1口的8个LED显示出来!
CLR P2.1    ;蜂鸣器鸣响－嘀嘀嘀－的声音，表示解码成功
LCALL YS2
LCALL YS2
LCALL YS2
SETB P2.1   ;蜂鸣器停止




EXIT: SETB EA ;允许中断
      RETI ;退出解码子程序




;-------------------------延时子程序---------------------------------




YS1: MOV R4,#20 ;延时子程序1，精确延时882微秒
D1: MOV R5,#20
    DJNZ R5,$
    DJNZ R4,D1
    RET




YS2: MOV R4,#10 ;延时子程序2，精确延时4740微秒
D2: MOV R5,#235
    DJNZ R5,$
    DJNZ R4,D2
    RET


YS3: MOV R4,#2;延时程序3，精确延时1000微秒
D3:MOV R5,#248
   DJNZ R5,$
   DJNZ R4,D3
   RET




END
