//实例97：用红外遥控器控制继电器
#include<reg51.h>       //包含单片机寄存器的头文件
sbit IR=P3^2;           //将IR位定义为P3.2引脚
unsigned char a[4];    //储存用户码、用户反码与键数据码、键数据反码
unsigned int LowTime,HighTime; //储存高、低电平的宽度 
sbit Relay=P1^3;      //将Relay位定义为P1.3引脚
/************************************************************
函数功能：对4个字节的用户码和键数据码进行解码
说明：解码正确，返回1，否则返回0
出口参数：dat
*************************************************************/
bit DeCode(void)        
{
    
   unsigned char  i,j;
	unsigned char temp;    //储存解码出的数据
	for(i=0;i<4;i++)      //连续读取4个用户码和键数据码
	  {
		 for(j=0;j<8;j++)  //每个码有8位数字
			 {
	         temp=temp>>1;  //temp中的各数据位右移一位，因为先读出的是高位数据									
			   TH0=0;         //定时器清0
			   TL0=0;         //定时器清0
			   TR0=1;         //开启定时器T0
		      while(IR==0)   //如果是低电平就等待
	               ;	      //低电平计时
		  	   TR0=0;         //关闭定时器T0
			   LowTime=TH0*256+TL0;    //保存低电平宽度
			   TH0=0;         //定时器清0
			   TL0=0;         //定时器清0
			   TR0=1;         //开启定时器T0
			   while(IR==1)   //如果是高电平就等待
			       ;			   
			   TR0=0;        //关闭定时器T0
			   HighTime=TH0*256+TL0;   //保存高电平宽度
			   if((LowTime<370)||(LowTime>640))
			  		    return 0;        //如果低电平长度不在合理范围，则认为出错，停止解码			
			   if((HighTime>420)&&(HighTime<620))   //如果高电平时间在560微秒左右，即计数560／1.085＝516次
			           temp=temp&0x7f;       //(520-100=420, 520+100=620)，则该位是0
			   if((HighTime>1300)&&(HighTime<1800)) //如果高电平时间在1680微秒左右，即计数1680／1.085＝1548次
			           temp=temp|0x80;       //(1550-250=1300,1550+250=1800),则该位是1
		     }  			            
	   a[i]=temp;	//将解码出的字节值储存在a[i]																					 
    }  				 		 
  if(a[2]=~a[3])  //验证键数据码和其反码是否相等,一般情况下不必验证用户码
	 return 1;     //解码正确，返回1
}
/************************************************************
函数功能：执行遥控功能
*************************************************************/
void Function(void)
{
   Relay=!Relay;   //对P1.3引脚取反，控制继电器的吸合、释放
  
}
/************************************************************
函数功能：主函数
*************************************************************/
void main()
{		 
	EA=1;        //开启总中断
   EX0=1;       //开外中断0
   ET0=1;       //定时器T0中断允许
   IT0=1;       //外中断的下降沿触发  
	TMOD=0x01;   //使用定时器T0的模式1
	TR0=0;       //定时器T0关闭
	while(1)    //等待红外信号产生的中断
		;		 
}
/************************************************************
函数功能：红外线触发的外中断处理函数
*************************************************************/
void Int0(void) interrupt 0 using 0
  {
     EX0=0;      //关闭外中断0，不再接收二次红外信号的中断，只解码当前红外信号
	  TH0=0;      //定时器T0的高8位清0
	  TL0=0;      //定时器T0的低8位清0
	  TR0=1;	    //开启定时器T0	 
	  while(IR==0)          //如果是低电平就等待，给引导码低电平计时
	       ;     
	  TR0=0;                //关闭定时器T0     
	  LowTime=TH0*256+TL0;  //保存低电平时间
	  TH0=0;      //定时器T0的高8位清0
	  TL0=0;      //定时器T0的低8位清0
	  TR0=1;	    //开启定时器T0
	  while(IR==1)  //如果是高电平就等待，给引导码高电平计时
	    ;
	  TR0=0;        //关闭定时器T0
	  HighTime=TH0*256+TL0;	//保存引导码的高电平长度
     if((LowTime>7800)&&(LowTime<8800)&&(HighTime>3600)&&(HighTime<4700))
		 {
		    //如果是引导码,就开始解码,否则放弃,引导码的低电平计时
	       //次数＝9000us/1.085=8294, 判断区间:8300－500＝7800，8300＋500＝8800.
	       if(DeCode()==1)	
	 	    Function();	   //如果满足条件，执行遥控功能
		 }
	  EX0=1;   //开启外中断EX0
  }
