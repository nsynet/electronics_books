//实例47：用定时器T1中断控制两个LED以不同周期闪烁
#include<reg51.h>  //  包含51单片机寄存器定义的头文件
sbit D1=P2^0;  //将D1位定义为P2.0引脚
sbit D2=P2^1;  //将D2位定义为P2.1引脚
unsigned char Countor1; //设置全局变量，储存定时器T1中断次数
unsigned char Countor2; //设置全局变量，储存定时器T1中断次数
/**************************************************************
函数功能：主函数
**************************************************************/
void main(void)
{
   EA=1;                  //开总中断
	ET1=1;                 //定时器T1中断允许         
	TMOD=0x10;             //使用定时器T1的模式1
	TH1=(65536-46083)/256; //定时器T1的高8位赋初值
	TL1=(65536-46083)%256; //定时器T1的高8位赋初值
	TR1=1;                 //启动定时器T1
	Countor1=0;            //从0开始累计中断次数
	Countor2=0;            //从0开始累计中断次数 
	while(1)//无限循环等待中断
       ;
 }
/**************************************************************
函数功能：定时器T1的中断服务程序
**************************************************************/
void Time1(void) interrupt 3 using 0 //“interrupt”声明函数为中断服务函数
                 //其后的3为定时器T1的中断编号；0表示使用第0组工作寄存器 
 {
   Countor1++;   //Countor1自加1
	Countor2++;   //Countor2自加1
	if(Countor1==2)  //若累计满2次，即计时满100ms
		{
		   D1=~D1;     //按位取反操作，将P2.0引脚输出电平取反
			Countor1=0;  //将Countor1清0，重新从0开始计数
		}
	if(Countor2==8)  //若累计满8次，即计时满400ms
		{
		   D2=~D2;     //按位取反操作，将P2.1引脚输出电平取反
			Countor2=0;  //将Countor1清0，重新从0开始计数
		}		
  	TH1=(65536-46083)/256; //定时器T1的高8位重新赋初值
	TL1=(65536-46083)%256; //定时器T1的高8位重新赋初值
 }

