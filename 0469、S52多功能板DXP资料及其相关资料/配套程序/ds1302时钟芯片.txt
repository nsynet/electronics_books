 #include<reg52.h>
 #include<intrins.h>
 #define uchar  unsigned char
 #define uint  unsigned int
 uchar led [10]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x98};	//数码管显示0-9的字节
 uchar postion [8]={0x7f,0xbf, 0xdf, 0xef,0xf7,0xfb, 0xfd,0xfe };						// 数码管的为控制字节
 uchar timer[3];														// 时间的数组
 uchar disbruff[6];															// 保存每个数码管要显示的字节
  /**************************************************************************
				   DS1302专用
**************************************************************************/

sbit     sclk      = P3^6;   /*实时时钟时钟线引脚 */
sbit     io       = P3^5;   /*实时时钟数据线引脚 */
sbit     rst      = P3^4;   /*实时时钟复位线引脚 */
bdata uchar date_bruff;
sbit flag0=date_bruff^0;												
sbit flag7=date_bruff^7;
uchar bcd_bruff[8];
/****************************************************************************
				 延时函数
****************************************************************************/
void delay_ms(uchar n)	  
{ 
	unsigned int i,j,k;

	for(i=0;i<n;i++)
	{				
		for(k=0;k<4;k++)
		{  
			for(j=0;j<10;j++);	
		}
	}
}
 /**************************************************************************
      将要显示的时间数据经过timer――to――disbruff转换到disbruff[]内
 **************************************************************************/
 void  timer_to_disbruff()
 {
    uchar i,A=0;	                                //A=0 importment
    for(i=0;i<3;i++)
     {
       disbruff[A++]=timer[i]%10;                   //取数据的各位			 
       disbruff[A++]=timer[i]/10 ;                  // 取数据的十位
     }
 }




/***************************************************************************
           字节传送
		   功能：上升沿传送一个数据位的最低位
		   用途：用于字节的传送
****************************************************************************/
void inputbety (uchar ucdate)
{
   uchar i;
   date_bruff=ucdate; //  将要传送的数据赋值给date_bruff
   for(i=0;i<8;i++)	   //	循环8次按位传送一个字节
    {
      io=flag0;			//  将最低位赋值给io
	  sclk=1;			  //  触发上升沿传送一个位
	  sclk=0;				//	 sclk变低准备下一个上升沿
	  date_bruff=date_bruff>>1;//数据移位将依次右移一位，依次传送0，1，2，3，4，5，6，7
    }
}
/***************************************************************************
             字节的读取
			 功能：上升沿读取一个数据的最低位
			 用途：用于读取字节
***************************************************************************/
uchar outputbety()
{
  uchar j;
  for(j=0;j<8;j++)
   { 
 	 date_bruff=date_bruff>>1;    //先右移一位准备接受读取的数据位
     flag7=io;  				  //把读取的数据赋值给date_bruff的第7位
	 sclk=1;					  //触发上升沿肚脐眼一个位
	 sclk=0;					  // 变低准备下一个上升沿
    }								  
	return date_bruff;		      //返回读取的数据		
}
/****************************************************************************
					   地址字节和数据的传送
					   功能：调用inputbety（）；先写地址，紧接着写地址内的数据
					   用途：配置DS1302的内部寄存器
****************************************************************************/
void wdate(uchar addr, uchar date)
{
    rst=0;		    //变低为sclk变低允许
	sclk=0;		    // 变低准备上升沿
	rst=1;			//	 使能对ds1302进行操作
	inputbety(addr); //写入地址
	inputbety(date); //写入数据  
    sclk=1;			   
	rst=0;				  
}						  
/***************************************************************************
				数据的读取
				功能：写写入要读取数据的地址和指令；然后调用output（）
				用途：用于读取ds1302的实时时间
***************************************************************************/
uchar rdate(uchar addrx)
{
    uchar readdate;
    rst=0;
	sclk=0;
	rst=1;
	inputbety(addrx);//写入控制命令的字节和数据
	readdate=outputbety(); // 读取数据
    sclk=1;
	rst=0;
	return readdate;	   //  返回数据
}
void initial_ds1302(void)   //时钟芯片初始化
{   
	unsigned char second=rdate(0x80);
	if(second&0x80)	          //判断时钟芯片是否关闭	  
    {
	  wdate(0x8e,0x00);      //写入允许
	  wdate(0x8c,0x07);      //以下写入初始化时间 日期:07/07/25.星期: 3. 时间: 23:59:56
	  wdate(0x88,0x07);
	  wdate(0x86,0x15);
	  wdate(0x8a,0x07);
	  wdate(0x84,0x23);
	  wdate(0x82,0x59);
	  wdate(0x80,0x55);
  	  wdate(0x8e,0x80);    //禁止写入
	}				    
}	 
void readds1302() //读取数据的BCD
{
 uchar i;
 for(i=0;i<7;i++)
 {
   bcd_bruff[i]=rdate(0x81+2*i);// 依次读取数据存储在bcd_bruff数组内
 }
}
/**********************************************************************************
	        将读取的BCD吗转换成能在数码管上显示的数据
******************************************************************************/
void bcd_to_timer()
{ 
  uchar k;
  for(k=0;k<3;k++)
   {
      timer[k]=((bcd_bruff[k]&0xf0)>>4)*10 + (bcd_bruff[k]&0x0f) ;   
    }
}
/*******************************************************************************
                 	数码管的动态显示函数
*******************************************************************************/
void display()
{
 uchar i;
  for(i=0;i<6;i++)
  {
    P0=led[disbruff[i]];
    P1=postion[i];
    delay_ms(5);
  }	
}
/********************************************************************************

	                                 主函数	   
  
*******************************************************************************/
 void main()
 {
   
  timer[0]=00;
   timer[2]=00;
   timer[1]=00;
  timer_to_disbruff();
   initial_ds1302();

  while(1)
   { 
	 readds1302();
	 bcd_to_timer(); 
	 timer_to_disbruff();  
     display();
    };
 }