Sunplus u'nSP Assembler - Ver. 1.8.0

                            	//========================================================================================
                            	// Progarm: Function definition for PC play data transmition
                            	// Writen by: Andy
                            	//
                            	// Last modified date: 
                            	// 		2000/06/23: first definition
                            	//		2000/07/15: modify
                            	//		2000/11/07: eliminate file head(103)
                            	// Functions:
                            	//  (Assembly view)
                            	//  F_PcPlay_Initial							// PcPlay service initialization
                            	//	F_PcPlay_ServiceLoop						// PcPlay service loop
                            	//	F_PcPlay_GetQueue							// Get data from queue 
                            	
                            	//  (C language view)
                            	//	_PcPlay_Initial							// PcPlay service initialization called by C
                            	//	_PcPlay_ServiceLoop 						// PcPlay service loop called by C
                            	//	_PcPlay_GetQueue							// Get data from queue
                            	
                            	//	F_CheckLPT1DataIn						
                            	//		-F_DataGet0							// call by F_CheckLPT1DataIn:
                            	//========================================================================================
                            	
                            	.include hardware.inc;
                     <      	//========================================================================================
                     <      	// Progarm: The file be included by modules
                     <      	// Arranged by: Andy Hsu
                     <      	// Date: 	2000/06/23: first version
                     <      	//		2000/07/24: modified
                     <      	//		2000/10/20: modified for version 52A
                     <      	//========================================================================================
                     <      	//////////////////////////////////////////////////////////////////
                     <      	// Definitions for I/O Port
                     <      	//////////////////////////////////////////////////////////////////
                     <      	.DEFINE	P_IOA_Data   		0x7000;        // Write Data into data register and read from IOA pad
                     <      	.DEFINE P_IOA_Buffer        0x7001;        // Write Data into buffer register and read from buffer register
                     <      	.DEFINE P_IOA_Dir           0x7002;        // Direction vector for IOA
                     <      	.DEFINE P_IOA_Attrib        0x7003;        // Attribute vector for IOA
                     <      	.DEFINE P_IOA_Latch         0x7004;        // Latch PortA data for key change wake-up
                     <      	
                     <      	.DEFINE P_IOB_Data         	0x7005;        // Write Data into the data register and read from IOB pad
                     <      	.DEFINE P_IOB_Buffer        0x7006;        // Write Data into buffer register and read from buffer register
                     <      	.DEFINE P_IOB_Dir           0x7007;        // Direction vector for IOB
                     <      	.DEFINE P_IOB_Attrib        0x7008;        // Attribute vector for IOB
                     <      	
                     <      	.DEFINE P_FeedBack          0x7009;        // Clock form external R,C
                     <      	.DEFINE P_TimerA_Data       0x700A;        // Data port for TimerA 
                     <      	.DEFINE P_TimerA_Ctrl       0x700B;        // Control Port for TimerA
                     <      	.DEFINE P_TimerB_Data       0x700C;        // Data port for TimerB
                     <      	.DEFINE P_TimerB_Ctrl       0x700D;        // Control Port for TimerB
                     <      	.DEFINE P_TimeBase_Setup    0x700E;        // TimerBase Freq. Set
                     <      	.DEFINE P_TimeBase_Clear	0x700F;		   // Reset Timerbase counter
                     <      	.DEFINE P_INT_Ctrl          0x7010;        // Control port for interrupt source
                     <      	.DEFINE P_INT_Clear         0x7011;        // Clear interrupt source
                     <      	.DEFINE P_Watchdog_Clear    0x7012;        // Watchdog Reset
                     <      	.DEFINE P_SystemClock       0x7013;        // Change system clock frequency(include go to standby mode)
                     <      	
                     <      	//... PA6442 Old version (for EC-02) ...........
                     <      	//.DEFINE P_ADDA               0x7014;        //10-bit DA(W) AD(R)
                     <      	//.DEFINE P_DAC1               0x7014;        //
                     <      	//.DEFINE P_AD_Ctrl            0x7015;        //AD/DA control
                     <      	//.DEFINE P_AD_Status          0x7015;        //AD status
                     <      	//.DEFINE P_DAC2               0x7016;        //DAC channel 2
                     <      	//.DEFINE P_PWM                0x7016;        //PWM output
                     <      	//.DEFINE P_DA_Ctrl            0x7017;        //DAC latch control
                     <      	
                     <      	//... PA6442 New version MC52A (For EC-03)....
                     <      	.DEFINE P_ADC 	        	0x7014;        	// Data Port for AD
                     <      	.DEFINE P_ADC_Ctrl          0x7015;        	// Control Port for AD control
                     <      	.DEFINE P_ADC_Status        0x7015;        	// AD Port Status
                     <      	.DEFINE P_DAC2              0x7016;        	// Data Port for DAC2
                     <      	.DEFINE P_PWM               0x7016;        	// Data Port for PWM
                     <      	.DEFINE P_DAC1	        	0x7017;        	// Data Port for DAC1
                     <      	.DEFINE P_DAC_Ctrl			0x702A;			// Control Port for two DAC and audio output mode
                     <      	//............................................
                     <      	
                     <      	.DEFINE P_IR_Ctrl			0x7018;			// Control Port for IR
                     <      	.DEFINE P_LVD_Ctrl          0x7019;        	// Control Port for LVD
                     <      	
                     <      	.DEFINE P_SIO_Addr_Low		0x701B;			// Address Port low
                     <      	.DEFINE P_SIO_Addr_Mid		0x701C;			// Address Port middle
                     <      	.DEFINE P_SIO_Addr_High	 	0x701D;			// Address Port high
                     <      	.DEFINE P_SIO_Ctrl			0x701E;			// Control Port
                     <      	.DEFINE P_SIO_Start			0x701F;			// Start port for serial interface
                     <      	.DEFINE P_SIO_Stop			0x7020;			// Stop port for serial interface
                     <      	
                     <      	.DEFINE P_UART_Command1		 0x7021;		// Command1 Port for UART
                     <      	.DEFINE P_UART_Command2		 0x7022;		// Command2 Port for UART
                     <      	.DEFINE P_UART_Data			 0x7023; 		// Data Port for UART
                     <      	.DEFINE	P_UART_BaudScalarLow 0x7024;		// Set Baud Rate scalar low
                     <      	.DEFINE	P_UART_BaudScalarHigh 0x7025;		// Set Baud Rate scalar high
                     <      	
                     <      	
                     <      	//... Definitions for P_INT_Ctrl ..............
                     <      	.DEFINE C_IRQ6_TMB2             0x0001;        	// Timer B IRQ6
                     <      	.DEFINE C_IRQ6_TMB1             0x0002;        	// Timer A IRQ6
                     <      	.DEFINE C_IRQ5_2Hz              0x0004;        	// 2Hz IRQ5
                     <      	.DEFINE C_IRQ5_4Hz              0x0008;        	// 4Hz IRQ5
                     <      	.DEFINE C_IRQ4_1KHz             0x0010;        	// 1024Hz IRQ4
                     <      	.DEFINE C_IRQ4_2KHz             0x0020;        	// 2048Hz IRQ4
                     <      	.DEFINE C_IRQ4_4KHz             0x0040;        	// 4096Hz IRQ4
                     <      	.DEFINE C_IRQ3_KEY              0x0080;        	// Key Change IRQ3
                     <      	.DEFINE C_IRQ3_EXT1             0x0100;        	// Ext1 IRQ3
                     <      	.DEFINE C_IRQ3_EXT2             0x0200;        	// Ext2 IRQ3
                     <      	.DEFINE C_IRQ2_TMB              0x0400;        	// Timer B IRQ2
                     <      	.DEFINE C_FIQ_TMB               0x0800;        	// Timer B FIQ
                     <      	.DEFINE C_IRQ1_TMA              0x1000;        	// Timer A IRQ1
                     <      	.DEFINE C_FIQ_TMA               0x2000;        	// Timer A FIQ
                     <      	.DEFINE C_IRQ0_PWM              0x4000;        	// PWM IRQ0
                     <      	.DEFINE C_FIQ_PWM               0x8000;        	// PWM FIQ
                     <      	
                     <      	// Definitions for P_TimerA/B_Ctrl ............                               
                     <      	.DEFINE	C_Fosc_2				0x0000;			// 
                     <      	.DEFINE	C_Fosc_256		    	0x0001;			//
                     <      	.DEFINE	C_32768Hz				0x0002;			//
                     <      	.DEFINE	C_8192Hz				0x0003;			//
                     <      	.DEFINE	C_4096Hz				0x0004;			//
                     <      	.DEFINE	C_A1					0x0005;			//
                     <      	.DEFINE C_A0					0x0006;			//
                     <      	.DEFINE C_Ext1					0x0007;			//
                     <      	
                     <      	.DEFINE	C_2048Hz				0x0000;			//
                     <      	.DEFINE	C_1024Hz				0x0008;			//
                     <      	.DEFINE	C_256Hz					0x0010;			//
                     <      	.DEFINE	C_TMB1Hz				0x0018;			//
                     <      	.DEFINE	C_4Hz					0x0020;			//
                     <      	.DEFINE	C_2Hz					0x0028;			//
                     <      	.DEFINE	C_B1					0x0030;			//
                     <      	.DEFINE	C_Ext2					0x0038;			//
                     <      	
                     <      	.DEFINE	C_Off					0x0000;			//
                     <      	.DEFINE C_D1					0x0040;			//
                     <      	.DEFINE C_D2					0x0080;			//
                     <      	.DEFINE C_D3					0x00C0;			//
                     <      	.DEFINE C_D4					0x0100;			//
                     <      	.DEFINE C_D5					0x0140;			//
                     <      	.DEFINE C_D6					0x0180;			//
                     <      	.DEFINE C_D7					0x01C0;			//
                     <      	.DEFINE C_D8					0x0200;			//
                     <      	.DEFINE C_D9					0x0240;			//
                     <      	.DEFINE C_D10					0x0280;			//
                     <      	.DEFINE C_D11					0x02C0;			//
                     <      	.DEFINE C_D12					0x0300;			//
                     <      	.DEFINE C_D13					0x0340;			//
                     <      	.DEFINE C_D14					0x0380;			//
                     <      	.DEFINE C_TA_Div_2				0x03C0;			// Timer A
                     <      	.DEFINE C_TB_Div_2				0x03C0;			// Timer B
                     <      	
                     <      	//... Definition for P_SystemClock ............
                     <      	.DEFINE C_Fosc					0x0000;			// b3..b0
                     <      	.DEFINE C_Fosc_Div_2			0x0001;			//
                     <      	.DEFINE C_Fosc_Div_4			0x0002;			//
                     <      	.DEFINE C_Fosc_Div_8			0x0003;			// (default)
                     <      	.DEFINE C_Fosc_Div_16			0x0004;			//
                     <      	.DEFINE C_Fosc_Div_32			0x0005;			//
                     <      	.DEFINE C_Fosc_Div_64			0x0006;			//
                     <      	.DEFINE C_Sleep					0x0007;		 	//
                     <      	
                     <      	.DEFINE	C_32K_Work				0x0000;			// b4
                     <      	.DEFINE C_32K_Off				0x0000;			// 
                     <      	.DEFINE C_StrongMode			0x0000;			// b5
                     <      	.DEFINE C_AutoMode				0x0000;			//
                     <      	
                     <      	//... Define for P_AD_Ctrl ....................
                     <      	.DEFINE	C_AD					0x0001;			//
                     <      	.DEFINE C_DA					0x0000;			//
                     <      	.DEFINE C_MIC					0x0000;			//
                     <      	.DEFINE C_LINE					0x0002;			//
                     <      	
                     <      	//... Define for P_DA_Ctrl ....................
                     <      	.DEFINE C_PushPull				0x0000;			// b0, (default) 
                     <      	.DEFINE C_DoubleEnd				0x0001;			// b0
                     <      	.DEFINE	C_DAC_Mode				0x0000;			// b1, (default)
                     <      	.DEFINE C_PWM_Mode				0x0002;			// b1
                     <      	
                     <      	.DEFINE	C_D1_Direct				0x0000;			// DAC1 latch
                     <      	.DEFINE C_D1_LatchA				0x0008;			// 
                     <      	.DEFINE C_D1_LatchB				0x0010;			//
                     <      	.DEFINE C_D1_LatchAB			0x0018;			//
                     <      	
                     <      	.DEFINE	C_D2_Direct				0x0000;			// DAC2 latch
                     <      	.DEFINE C_D2_LatchA				0x0020;			// 
                     <      	.DEFINE C_D2_LatchB				0x0040;			//
                     <      	.DEFINE C_D2_LatchAB			0x00C0;			//
                     <      	
                     <      	//... Define for P_LVD_Ctrl ...................
                     <      	.DEFINE C_LVD24V				0x0000;			// LVD = 2.4V 
                     <      	.DEFINE C_LVD28V				0x0001;			// LVD = 2.8V
                     <      	.DEFINE C_LVD32V				0x0002;			// LVD = 3.2V
                     <      	.DEFINE C_LVD36V				0x0003;			// LVD = 3.6V
                     <      	
                     <      	
                     <      	.EXTERNAL	F_SP_Read_INT_Status;			// for further use
                     <      	.EXTERNAL 	F_SP_Write_INT_Status;			// for further use
                     <      	.EXTERNAL  	F_SP_Set_INT_Vector;			// for further use
                     <      	.EXTERNAL	F_SP_Clear_INT_Vector;			// for further use
                     <      	
                     <      	.EXTERNAL	F_SP_Send_Out;					//
                     <      	.EXTERNAL	F_SP_Send_DAC1;					//
                     <      	.EXTERNAL	F_SP_Send_DAC2;					//
                     <      	.EXTERNAL	F_SP_Send_Two_DAC;				//
                     <      	.EXTERNAL	F_SP_Init_HW;					//
                     <      	
                     <      	.EXTERNAL	R_InterruptStatus;
                     <      	
                     <      	
                     <      	.EXTERNAL 	F_SP_RampUpDAC1;
                     <      	.EXTERNAL 	F_SP_RampDnDAC1;
                     <      	.EXTERNAL 	F_SP_RampUpDAC2;
                     <      	.EXTERNAL  	F_SP_RampDnDAC2;
                     <      	
                     <      	.EXTERNAL 	F_SP_InitQueue;
                     <      	.EXTERNAL 	F_SP_ReadQueue;
                     <      	.EXTERNAL 	F_SP_WriteQueue;
                     <      	.EXTERNAL 	F_SP_TestQueue;
                     <      	
                     <      	
                     <      	
                     <      	.EXTERNAL	F_SP_Get_ADC
                     <      	
                     <      	.EXTERNAL 	F_SP_Set_P_TimerA_Ctrl
                     <      	.EXTERNAL 	F_SP_Set_P_TimerA_Data
                     <      	.EXTERNAL 	F_SP_Set_P_TimerB_Ctrl
                     <      	.EXTERNAL 	F_SP_Set_P_TimerB_Data
                     <      	.EXTERNAL 	F_SP_Set_P_INT_Ctrl
                     <      	.EXTERNAL 	F_SP_Set_P_INT_Clear
                     <      	.EXTERNAL 	F_SP_Set_P_SystemClock
                     <      	.EXTERNAL 	F_SP_Set_P_DAC_Ctrl
                     <      	.EXTERNAL 	F_SP_Set_P_ADC_Ctrl
                     <      	
                     <      		
                     <      	
                     <      	//--------------------------------------------
                     <      	SACM_MACRO1: 	.MACRO
                     <      		
                     <      		.ENDM
                     <      	
                     <      	SACM_MACRO2:	.MACRO
                     <      		
                     <      		.ENDM
                     <      	
                     <      	
                     <      	
                     <      	
                     <      	//.define PC_Play_Enable_A2000		1    	// Enable the PC-Play function for SACM-A2000 module
                     <      	//.define PC_Play_Enable_S480		1    	// Enable the PC-Play function for SACM-S480 module
                     <      	//.define PC_Play_Enable_S240		1    	// Enable the PC-Play function for SACM-S240 module    
                     <      	//.define PC_Play_Enable_MS01		1    	// Enable the PC-Play function for SACM-MS01 module
                     <      	
                     <      	
                     <      	
                     <      	//========================================================================================        
                     <      	// End of hardware.inc
                     <      	//========================================================================================
                            	
                            	//.define	CutFileHead	1;					// (103)
                            	
                            	.define D_Q_Buffer  0x100;				// for PC play
                            	.define D_BufferTail  D_Q_Buffer;
                            	.public	R_ReadIndex;
                            	.public R_WriteIndex;
                            	.public	R_BufferHead;
                            	
                            	//.RAM
00000000                    	PcPlay_Section:	.SECTION	.RAM
00000000 00 00              	.VAR    R_PCPlayFlag;					// for PC play
00000001 00 00              	.VAR    R_ReadIndex;
00000002 00 00              	.VAR    R_WriteIndex;
00000003 00 00              	.VAR    R_ResetCount;
00000004 00 00              	.VAR    R_DataTemp;
00000005 00 00              	.VAR    R_CommandTemp;
00000006 00 00              	.VAR    R_Temp;
00000007 00 00              	.VAR    R_Addr;
00000008 00 00              	.VAR    R_Bank;
                            	
                            	
00000009 00 00              	.VAR    R_BufferHead;
0000000A 00 00 00 00        	.DW		D_Q_Buffer-1 DUP(0);
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00      
                            	
00000109 00 00              	.var	R_ByteCount;
0000010A 00 00              	.var	R_HeadCounter;
0000010B 00 00              	.var 	R_Lpt1TimeOutCnt;
0000010C 00 00              	.var	R_Lpt1TimeOutCnt1;
                            	
                            	
00000000                    	.CODE
                            	//****************************************************************
                            	// Function: Initialization of LPT1
                            	// Input: None
                            	// Output: None
                            	//****************************************************************
                            	.public	_PcPlay_Initial;
                            	.public F_PcPlay_Initial;
                            	_PcPlay_Initial: .PROC
                            	F_PcPlay_Initial: 		
00000000 40 92              		 	r1 = 0;
00000001 19 D3 02 00        		 	[R_WriteIndex] = r1;
00000003 19 D3 01 00        	        [R_ReadIndex] = r1;
00000005 11 93 05 70        	        r1 = [P_IOB_Data];
00000007 19 D3 00 00        	        [R_PCPlayFlag] = r1;
                            	
                            			//...............................
00000009 40 92              			r1 = 0;		
0000000A 19 D3 0B 01        			[R_Lpt1TimeOutCnt] = r1;
0000000C 54 92              			r1 = 20;
0000000D 19 D3 0C 01        			[R_Lpt1TimeOutCnt1] = r1;
                            			
                            	L_NonPChaveData:
0000000F 11 93 0B 01        			r1 = [R_Lpt1TimeOutCnt];
00000011 41 22              			r1 -= 1;
00000012 19 D3 0B 01        			[R_Lpt1TimeOutCnt] = r1;
00000014 05 4E              			jnz	L_NoCarry;	
00000015 11 93 0C 01        			r1 = [R_Lpt1TimeOutCnt1];
00000017 41 22              			r1 -= 1;
00000018 19 D3 0C 01        			[R_Lpt1TimeOutCnt1] = r1;
                            	L_NoCarry:	
                            		
0000001A 11 93 0C 01        			r1 = [R_Lpt1TimeOutCnt1];
                            	
0000001C 11 93 0B 01        			r1 = [R_Lpt1TimeOutCnt];
0000001E 11 A3 0C 01        			r1 |= [R_Lpt1TimeOutCnt1];
00000020 02 4E              			jnz	L_Lpt1NotTimeOut;
00000021 80 FE 6D 00        			goto	L_Lpt1TimeOut
                            			
                            	L_Lpt1NotTimeOut:
00000023 41 92              			R1=0x0001;                      //clear watch dog
00000024 19 D3 12 70        	        [P_Watchdog_Clear]=R1;       //
00000026 11 93 05 70        	  		r1 = [P_IOB_Data];				//
00000028 01 95              		  	r2 = r1;
00000029 13 97 00 00        			r3 = [R_PCPlayFlag];
0000002B 03 83              	        r1 = r1 xor r3;
0000002C 09 B3 00 01        	        r1 = r1 and 0x0100;
0000002E 60 5E              	        jz  L_NonPChaveData;
                            	        
                            	
                            	                
                            			//.................................        
                            	        
                            	        
0000002F 0B 87 00 03        	        r3 = r3 xor 0x0300;
00000031 1B D7 00 00        	        [R_PCPlayFlag] = r3;
00000033 0B A7 FF 01        	        r3 = r3 or 0x01ff;
00000035 1B D7 05 70        	        [P_IOB_Data] = r3;
                            	
                            	
00000037 40 F0 04 01        			call F_CheckLPT1DataIn;
                            	//		cmp r4, 0xf001;						// 0xf001: SACM-A2000
                            	//		je		L_GoNextInit				// 0xf004: SACM-S480/S720
                            	//		PC = L_Reset;						// 0xf002: SACM-S240/S120
                            	//L_GoNextInit:								// 0xf008: FM4
                            												// 0xf009: FM6	
                            	
00000039 0C 49 01 F0        			cmp	r4, 0xf001;						//
0000003B 0B 5E              			je	L_DataIsSACM_A2000				//		
0000003C 0C 49 04 F0        			cmp	r4, 0xf004;						//
0000003E 0B 5E              			je	L_DataIsSACM_S480				//
0000003F 0C 49 02 F0        			cmp	r4, 0xf002;						//
00000041 0B 5E              			je	L_DataIsSACM_S240				//	
00000042 0C 49 08 F0        			cmp	r4, 0xf008;						//
00000044 0B 5E              			je	L_DataIsSACM_MS01				//
                            	
00000045 0F 9F 6E 00        			PC = L_WrongData;
                            	
                            	L_DataIsSACM_A2000:
00000047 0C 99 00 01        			r4 = 256;
00000049 08 EE              			jmp	L_PcPlayTypeSetReady;			//
                            	L_DataIsSACM_S480:
0000004A 0C 99 01 01        			r4 = 257;
0000004C 05 EE              			jmp	L_PcPlayTypeSetReady;			//
                            	L_DataIsSACM_S240:
0000004D 0C 99 02 01        			r4 = 258;
0000004F 02 EE              			jmp	L_PcPlayTypeSetReady;			//
                            	L_DataIsSACM_MS01:
00000050 0C 99 03 01        			r4 = 259;
                            		
                            	L_PcPlayTypeSetReady:
00000052 88 D8              			push	r4 to [sp];					// save return value
                            		
00000053 40 92              	        r1 = 0;
00000054 19 D3 05 00        	        [R_CommandTemp] = r1;
00000056 19 D3 09 01        	        [R_ByteCount] = r1;
00000058 19 D3 04 00        	        [R_DataTemp] = r1;
0000005A 19 D3 03 00        	        [R_ResetCount] = r1;
                            	
                            			
0000005C 40 92              			r1 = 0;							// reset R_EndCounter
0000005D 19 D3 0A 01        			[R_HeadCounter] = r1;			// (103)	
                            		
                            			//...... fill queue up ............		        
0000005F 40 9A              	        r5 = 0x00;
00000060 1D DB 06 00        	        [R_Temp] = r5;
                            	L_GetDataLoop0:
                            	        
00000062 40 F0 75 00        	        call F_PcPlay_ServiceLoop;			//F_CheckDataInAndSave;
                            	        
                            	        //r5 = R_BufferHead; // for test
                            	        	
00000064 15 9B 06 00        	        r5 = [R_Temp];
00000066 41 0A              	        r5 += 0x01;
00000067 1D DB 06 00        	        [R_Temp] = r5;
00000069 0D 4B 00 64        	        cmp r5, D_BufferTail*100; // use 10 because several times to fill one byte
                            	        //cmp	r5, D_BufferTail-1;
0000006B 4A 0E              	        jcc L_GetDataLoop0;
                            			//................................
                            	
                            			
                            			
                            			//r1 = R_BufferHead;			//for test
                            	
0000006C 88 90              			pop r1 from [sp];				// return value
                            			
                            	L_Lpt1TimeOut:		
0000006D 90 9A              			retf;	
                            			
                            	L_WrongData:
0000006E 41 92              			R1=0x0001;                      //clear watch dog
0000006F 19 D3 12 70        	        [P_Watchdog_Clear]=R1;       //
00000071 00 EE              			nop;
00000072 00 EE              			nop;
00000073 00 EE              			nop;
00000074 90 9A              			retf;	
                            	 		.ENDP;
                            			
                            	//****************************************************************
                            	// Function: Get data from printer port and put the data to the queue
                            	// Input: Port IOA
                            	// Output: Queue (see [R_QueueHead],[R_ReadIndex] and [R_WriteIndex] in detail
                            	//****************************************************************
                            	.public _PcPlay_ServiceLoop;				// original F_CheckDataInAndSave:
                            	.public F_PcPlay_ServiceLoop;
                            	_PcPlay_ServiceLoop: .PROC
                            	F_PcPlay_ServiceLoop:
                            			
00000075 41 92              			R1=0x0001;                      //clear watch dog
00000076 19 D3 12 70        	        [P_Watchdog_Clear]=R1;       //
                            	        
00000078 11 93 02 00        	        r1 = [R_WriteIndex];  			//check buffer Tail 
0000007A 12 95 01 00        	        r2 = [R_ReadIndex];  			//
0000007C 02 23              	        r1 = r1 - r2;
0000007D 04 6E              	        jpl L_QueueNonFullAndSave;
0000007E 09 43 FF FF        	        cmp  r1, 0xffff;
00000080 05 4E              	        jne  L_FillDataAndSave;
                            	L_QueueFullAndSave:
00000081 90 9A              	        retf;
                            	L_QueueNonFullAndSave:
00000082 09 43 FF 00        	        cmp r1, D_BufferTail-1;
00000084 01 4E              	        jne  L_FillDataAndSave;
00000085 90 9A              	        retf;							// queue full
                            	L_FillDataAndSave:
                            	//----------------------------------------
                            	                			
00000086 11 93 05 70        	        r1 = [P_IOB_Data];			//r2 = low byte, r3= high byte
00000088 01 95              	        r2 = r1;
00000089 13 97 00 00        	        r3 = [R_PCPlayFlag];
0000008B 03 83              	        r1 = r1 xor r3;
0000008C 09 B3 00 01        	        r1 = r1 and 0x0100;
0000008E 01 4E              	        jne L_PChaveData;
0000008F 90 9A              	        retf;
                            	L_PChaveData:
                            			
00000090 40 92              	        r1 = 0x00; //889
00000091 19 D3 03 00        	        [R_ResetCount] = r1;
                            	        
00000093 0B 87 00 03        	        r3 = r3 xor 0x0300;
00000095 1B D7 00 00        	        [R_PCPlayFlag] = r3;
00000097 0B A7 FF 01        	        r3 = r3 or 0x01ff;
                            	        
00000099 1B D7 05 70        	        [P_IOB_Data] = r3;
0000009B 5A 97              	        r3 = r2 lsl 4;
0000009C 5B 97              	        r3 = r3 lsl 4;
0000009D 0A B5 FF 00        	        r2 = r2 and 0x00ff;
0000009F 11 93 09 01        	        r1 = [R_ByteCount];
000000A1 09 09 01 00        	        r4 = r1 + 1;
000000A3 44 48              	        cmp     r4, 0x04;
000000A4 01 0E              	        jcc     L_UpDataCount;
000000A5 40 98              	        r4 = 0;
                            	L_UpDataCount:
                            			
000000A6 1C D9 09 01        	        [R_ByteCount] = r4;
000000A8 40 42              	        cmp r1, 0;
000000A9 1C 5E              	        je L_CommandCheck;
000000AA 41 42              	        cmp r1, 1;
000000AB 0A 5E              	        je L_DataCheck;
000000AC 42 42              	        cmp r1, 2;
000000AD 12 5E              	        je L_CommandCheck1;
000000AE 11 93 05 00        	        r1 = [R_CommandTemp];
000000B0 17 4E              	        jne L_IsCommand;
000000B1 14 99 04 00        	        r4 = [R_DataTemp];
000000B3 03 A9              	        r4 = r4 or r3;
000000B4 0F 9F DA 00        	        pc = F_SaveDataToBuffer;
                            	
                            	L_DataCheck:
000000B6 14 99 05 00        			r4 = [R_CommandTemp];
000000B8 04 4E              	        jne  L_IsCm2;
000000B9 1A D5 04 00        	        [R_DataTemp] = r2;
000000BB 0F 9F CF 00        	        pc = L_ZeroData;
                            	L_IsCm2:
000000BD 03 A9              	        r4 = r4 or r3;
000000BE 0F 9F D0 00        	        pc = F_CommandSet;
                            	
                            	L_CommandCheck1:
                            			
000000C0 40 46              	        cmp r3, 0;
000000C1 0D 5E              	        je   L_ZeroData;
000000C2 1B D7 05 00        	        [R_CommandTemp] = r3;
000000C4 0F 9F CF 00        	        pc = L_ZeroData;
                            	L_CommandCheck:
                            			
000000C6 40 46              	        cmp r3, 0;
000000C7 07 5E              	        je  L_ZeroData;
                            	L_IsCommand:
                            			
000000C8 13 97 05 00        	        r3 = [R_CommandTemp];
000000CA 02 A7              	        r3 = r3 or r2;
000000CB 1B D7 05 00        	        [R_CommandTemp] = r3;
000000CD 0F 9F D0 00        	        pc = F_CommandSet;
                            	L_ZeroData:
000000CF 90 9A              	        retf;
                            	
                            	F_CommandSet:
000000D0 40 92              	        r1 = 0;
000000D1 19 D3 05 00        	        [R_CommandTemp] = r1;
000000D3 19 D3 09 01        	        [R_ByteCount] = r1;
000000D5 19 D3 04 00        	        [R_DataTemp] = r1;
000000D7 19 D3 03 00        	        [R_ResetCount] = r1;
000000D9 90 9A              	        retf;
                            	//--------------------------------  
                            	F_SaveDataToBuffer:				// Save data to buffer
                            	
                            			//... Check File Head ....(103)
                            	.ifdef CutFileHead;	
                            	        push r1 to [sp];
                            	        
                            	        r1 = [R_HeadCounter];	// 
                            	        cmp	r1, 24;				//
                            	        jcs	L_NotFileHead;		//
                            	        
                            	        r1 = [R_HeadCounter];	//
                            	        r1 += 1;				// counter ++
                            	        [R_HeadCounter] = r1;	//
                            	        
                            	    	pop	r1 from [sp];		//    
                            			retf;					//
                            	    
                            	L_NotFileHead:        
                            	    	pop	r1 from [sp];    	//	
                            	.endif	    
                            	        //........................
                            			
                            		
                            	
                            	
000000DA 11 93 02 00        			r1 = [R_WriteIndex];  
000000DC 09 07 09 00        	        r3 = r1 + R_BufferHead;
000000DE C3 D8              	        [r3] = r4;
000000DF 41 02              	        r1 += 0x01;
000000E0 09 43 00 01        	        cmp  r1, D_BufferTail;
000000E2 01 0E              	        jcc L_NonOverTail;
000000E3 40 92              	        r1 = 0x00;
                            	L_NonOverTail:
000000E4 19 D3 02 00        	        [R_WriteIndex] = r1;
                            	        
                            	        
                            	        
000000E6 40 92              	        r1 = 0;
000000E7 19 D3 05 00        	        [R_CommandTemp] = r1;
000000E9 19 D3 09 01        	        [R_ByteCount] = r1;
000000EB 19 D3 04 00        	        [R_DataTemp] = r1;
000000ED 19 D3 03 00        	        [R_ResetCount] = r1;
                            	        
000000EF 90 9A              	        retf;
                            			.ENDP
                            		
                            	
                            	
                            	/////////////////////////////////////////////////////////
                            	// Function: Get data from queue 
                            	// Input: queue
                            	// Output: R4
                            	/////////////////////////////////////////////////////////
                            	.public	_PcPlay_GetQueue;        
                            	.public F_PcPlay_GetQueue;
                            	_PcPlay_GetQueue:
                            	F_PcPlay_GetQueue:
000000F0 13 97 01 00        	        r3 = [R_ReadIndex];
000000F2 14 99 02 00        	        r4 = [R_WriteIndex];  		//check buffer Tail
000000F4 04 47              	        cmp r3, r4;
000000F5 03 4E              	        jne L_Bufferhasdata_;
                            	        
000000F6 0C 99 FF FF        	        r4 = 0xffff;				// output 0xffff for speech end if queue is no data
                            	        
000000F8 90 9A              	        retf;
                            	L_Bufferhasdata_:
000000F9 0B 09 09 00        	        r4 = r3 + R_BufferHead;
000000FB C4 98              	        r4 = [r4];
000000FC 41 06              	        r3 += 0x01;
000000FD 0B 47 00 01        	        cmp  r3, D_BufferTail;
000000FF 01 0E              	        jcc L_RNonOverTail_;
00000100 40 96              	        r3 = 0x00;
                            	L_RNonOverTail_:
00000101 1B D7 01 00        	        [R_ReadIndex] = r3;
00000103 90 9A              	        retf;        
                            	        
                            	
                            	//============================================================================
                            	// Function: 
                            	// Input:
                            	// Output:
                            	// using: 
                            	//  call F_CheckLPT1DataIn;
                            	//  if z=0 data not comming yet, if z=1 data comming.
                            	//============================================================================
                            	F_CheckLPT1DataIn:
00000104 11 93 02 00        	        r1 = [R_WriteIndex];  			//check buffer Tail 
00000106 12 95 01 00        	        r2 = [R_ReadIndex];  			//
00000108 02 23              	        r1 = r1 - r2;
00000109 04 6E              	        jpl L_QueueNonFull;
0000010A 09 43 FF FF        	        cmp  r1, 0xffff;
0000010C 04 4E              	        jne  L_FillData;
                            	L_QueueFull:
0000010D 90 9A              	        retf;
                            	L_QueueNonFull:
0000010E 09 43 FF 00        	        cmp r1, D_BufferTail-1;
00000110 44 5E              	        je  L_QueueFull;
                            	L_FillData:
00000111 40 F0 18 01        	        call F_DataGet0;       //get one byte data from PC
00000113 03 99              	        r4 = r3;
00000114 40 F0 18 01        	        call F_DataGet0;
00000116 02 A9              	        r4 = r4 or r2;
                            	               
                            	//        cmp	r4, 0xf001;
                            	//        jne	L_DataNotComming;
                            	//        sr |= 0x0010;			// set z flag
                            	//L_DataNotComming:
                            	//		sr &= 0xFFEF;			// clear z flag        
00000117 90 9A              	       	retf;
                            		   
                            	
                            	///////////////////////////////////////////////////////
                            	// get one byte data from LPT1
                            	///////////////////////////////////////////////////////
                            	F_DataGet0:                				//r2 = low byte, r3= high byte
00000118 40 9A              	        r5 = 0x00;						// clear time out counter
00000119 1D DB 03 00        	        [R_ResetCount] = r5;			//889
                            	L_GetDataLoop1:
0000011B 41 92              			R1=0x0001;                      //clear watch dog
0000011C 19 D3 12 70        	        [P_Watchdog_Clear]=R1;       //
                            	
0000011E 11 93 05 70        	        r1 = [P_IOB_Data];
                            	        //call F_STD_GetIOA;
00000120 01 95              	        r2 = r1;
00000121 13 97 00 00        	        r3 = [R_PCPlayFlag];
00000123 03 83              	        r1 = r1 xor r3;
00000124 09 B3 00 01        	        r1 = r1 and 0x0100;
00000126 0C 4E              	        jne L_PChaveData1;
                            	        
00000127 11 93 03 00        	        r1 = [R_ResetCount];			// time out counter++
00000129 41 02              	        r1 += 0x01;						//889	
0000012A 19 D3 03 00        	        [R_ResetCount] = r1;			//
0000012C 52 4E              	        jne  L_GetDataLoop1;
0000012D 41 0A              	        r5 += 0x01;
0000012E 4F 4A              	        cmp     r5, 0x0f;
0000012F 55 0E              	        jcc  L_GetDataLoop1;
                            	        
                            	        //jmp	L_GetDataLoop1;
00000130 0F 9F 6E 00        	      	PC = L_WrongData;
00000132 90 9A              	        retf;
                            	        
                            	L_PChaveData1:
00000133 0B 87 00 03        	        r3 = r3 xor 0x0300;
00000135 1B D7 00 00        	        [R_PCPlayFlag] = r3;
00000137 0B A7 FF 01        	        r3 = r3 or 0x01ff;
00000139 1B D7 05 70        	        [P_IOB_Data] = r3;
                            	    
                            	    	//push r1,r1 to [sp];	
                            	        //r1 = r3;
                            	        //call F_STD_PutIOA;	
                            			//pop	r1,r1 from [sp];
                            	        
0000013B 5A 97              	        r3 = r2 lsl 4;
0000013C 5B 97              	        r3 = r3 lsl 4;
0000013D 0A B5 FF 00        	        r2 = r2 and 0x00ff;
0000013F 90 9A              			retf;
                            	
                            	
                            			//... For MS01 only .........................
                            	.public F_GetQueueNoChangeAddr;		
                            	F_GetQueueNoChangeAddr:
00000140 13 97 01 00        	        r3 = [R_ReadIndex];
00000142 14 99 02 00        	        r4 = [R_WriteIndex];  		//check buffer Tail
00000144 04 47              	        cmp r3, r4;
00000145 01 4E              	        jne L_Bufferhasdata_1;
00000146 90 9A              	        retf;
                            	L_Bufferhasdata_1:
00000147 0B 09 09 00        	        r4 = r3 + R_BufferHead;
00000149 C4 98              	        r4 = [r4];
0000014A 90 9A              	        retf;
                            	        
                            	.public	F_QueueAddrAdd1;        
                            	F_QueueAddrAdd1:
0000014B 13 97 01 00        			r3 = [R_ReadIndex];        
0000014D 41 06              	        r3 += 0x01;
0000014E 0B 47 00 01        	        cmp  r3, D_BufferTail;
00000150 01 0E              	        jcc L_RNonOverTail_1;
00000151 40 96              	        r3 = 0x00;
                            	L_RNonOverTail_1:
00000152 1B D7 01 00        	        [R_ReadIndex] = r3;
00000154 90 9A              	        retf;               
                            	        //.............................................
                            	        
                            	
                            	//============================================================================
                            	// Function: 3 Byte R_Lpt1TimeOutCnt ++
                            	// Input: None
                            	// Output: None
                            	// Used variable: R3
                            	//============================================================================
                            	F_Lpt1TimeOutCntAdd1:
00000155 13 97 0B 01        	        R3=[R_Lpt1TimeOutCnt];
00000157 41 06              	        R3 +=1;
00000158 1B D7 0B 01        	        [R_Lpt1TimeOutCnt]=R3;
0000015A 01 5E              	        jz      L_LT_Carry1;
0000015B 90 9A              	        retf;
                            	L_LT_Carry1:
0000015C 13 97 0C 01        	        R3=[R_Lpt1TimeOutCnt+1];
0000015E 41 06              	        R3 +=1;
0000015F 1B D7 0C 01        	        [R_Lpt1TimeOutCnt+1]=R3;
00000161 01 5E              	        jz      L_LT_Carry2;
00000162 90 9A              	        retf;
                            	L_LT_Carry2:
00000163 13 97 0D 01        	        R3=[R_Lpt1TimeOutCnt+2];
00000165 41 06              	        R3 +=1;
00000166 1B D7 0D 01        	        [R_Lpt1TimeOutCnt+2]=R3;
00000168 90 9A              	        retf;
                            	//============================================================================        
0 error(s), 0 warning(s).
